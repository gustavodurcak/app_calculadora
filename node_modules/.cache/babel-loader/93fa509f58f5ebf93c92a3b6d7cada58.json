{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  class ArrayNode extends Node {\n    /**\n     * @constructor ArrayNode\n     * @extends {Node}\n     * Holds an 1-dimensional array with items\n     * @param {Node[]} [items]   1 dimensional array with items\n     */\n    constructor(items) {\n      super();\n      this.items = items || []; // validate input\n\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected');\n      }\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isArrayNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var evalItems = map(this.items, function (item) {\n        return item._compile(math, argNames);\n      });\n      var asMatrix = math.config.matrix !== 'Array';\n\n      if (asMatrix) {\n        var matrix = math.matrix;\n        return function evalArrayNode(scope, args, context) {\n          return matrix(map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          }));\n        };\n      } else {\n        return function evalArrayNode(scope, args, context) {\n          return map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          });\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.items.length; i++) {\n        var node = this.items[i];\n        callback(node, 'items[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new ArrayNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ArrayNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var items = [];\n\n      for (var i = 0; i < this.items.length; i++) {\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n      }\n\n      return new ArrayNode(items);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ArrayNode}\n     */\n\n\n    clone() {\n      return new ArrayNode(this.items.slice(0));\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    _toString(options) {\n      var items = this.items.map(function (node) {\n        return node.toString(options);\n      });\n      return '[' + items.join(', ') + ']';\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        items: this.items\n      };\n    }\n    /**\n     * Instantiate an ArrayNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n     *                       where mathjs is optional\n     * @returns {ArrayNode}\n     */\n\n\n    static fromJSON(json) {\n      return new ArrayNode(json.items);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    toHTML(options) {\n      var items = this.items.map(function (node) {\n        return node.toHTML(options);\n      });\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      function itemsToTex(items, nested) {\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n        var itemsFormRow = nested || mixedItems;\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n        var itemsTex = items.map(function (node) {\n          if (node.items) {\n            return itemsToTex(node.items, !nested);\n          } else {\n            return node.toTex(options);\n          }\n        }).join(itemSep);\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n      }\n\n      return itemsToTex(this.items, false);\n    }\n\n  }\n\n  _defineProperty(ArrayNode, \"name\", name);\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isArrayNode","isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","constructor","items","Array","isArray","every","TypeError","type","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","itemsToTex","nested","mixedItems","some","itemsFormRow","itemSep","itemsTex","toTex","isClass"],"sources":["/Users/gustavodurcak/node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isArrayNode, isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  class ArrayNode extends Node {\n    /**\n     * @constructor ArrayNode\n     * @extends {Node}\n     * Holds an 1-dimensional array with items\n     * @param {Node[]} [items]   1 dimensional array with items\n     */\n    constructor(items) {\n      super();\n      this.items = items || []; // validate input\n\n      if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected');\n      }\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isArrayNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var evalItems = map(this.items, function (item) {\n        return item._compile(math, argNames);\n      });\n      var asMatrix = math.config.matrix !== 'Array';\n\n      if (asMatrix) {\n        var matrix = math.matrix;\n        return function evalArrayNode(scope, args, context) {\n          return matrix(map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          }));\n        };\n      } else {\n        return function evalArrayNode(scope, args, context) {\n          return map(evalItems, function (evalItem) {\n            return evalItem(scope, args, context);\n          });\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.items.length; i++) {\n        var node = this.items[i];\n        callback(node, 'items[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new ArrayNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ArrayNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var items = [];\n\n      for (var i = 0; i < this.items.length; i++) {\n        items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n      }\n\n      return new ArrayNode(items);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ArrayNode}\n     */\n\n\n    clone() {\n      return new ArrayNode(this.items.slice(0));\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    _toString(options) {\n      var items = this.items.map(function (node) {\n        return node.toString(options);\n      });\n      return '[' + items.join(', ') + ']';\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        items: this.items\n      };\n    }\n    /**\n     * Instantiate an ArrayNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n     *                       where mathjs is optional\n     * @returns {ArrayNode}\n     */\n\n\n    static fromJSON(json) {\n      return new ArrayNode(json.items);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n\n\n    toHTML(options) {\n      var items = this.items.map(function (node) {\n        return node.toHTML(options);\n      });\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      function itemsToTex(items, nested) {\n        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);\n        var itemsFormRow = nested || mixedItems;\n        var itemSep = itemsFormRow ? '&' : '\\\\\\\\';\n        var itemsTex = items.map(function (node) {\n          if (node.items) {\n            return itemsToTex(node.items, !nested);\n          } else {\n            return node.toTex(options);\n          }\n        }).join(itemSep);\n        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? '\\\\begin{bmatrix}' + itemsTex + '\\\\end{bmatrix}' : itemsTex;\n      }\n\n      return itemsToTex(this.items, false);\n    }\n\n  }\n\n  _defineProperty(ArrayNode, \"name\", name);\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}