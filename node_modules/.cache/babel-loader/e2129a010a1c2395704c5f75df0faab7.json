{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n\n    if (isConstantNode(curNode)) return true;\n\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n\n    return false;\n  }\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  class OperatorNode extends Node {\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super(); // validate input\n\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isOperatorNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n\n      if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new OperatorNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var args = [];\n\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {OperatorNode}\n     */\n\n\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n    /**\n     * Check whether this is an unary OperatorNode:\n     * has exactly one argument, like `-a`.\n     * @return {boolean}\n     *     Returns true when an unary operator node, false otherwise.\n     */\n\n\n    isUnary() {\n      return this.args.length === 1;\n    }\n    /**\n     * Check whether this is a binary OperatorNode:\n     * has exactly two arguments, like `a + b`.\n     * @return {boolean}\n     *     Returns true when a binary operator node, false otherwise.\n     */\n\n\n    isBinary() {\n      return this.args.length === 2;\n    }\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        } // for example for \"not\", we want a space between operand and argument\n\n\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        } // fall back to postfix\n\n\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n\n        var rhs = args[1].toString(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n\n          return arg;\n        });\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"OperatorNode\",\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n     *      \"implicit\": false,\n     *      \"isPercentage\":false}\n     *     ```\n     *     where mathjs is optional\n     * @returns {OperatorNode}\n     */\n\n\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n    /**\n     * Get HTML representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n\n        var rhs = args[1].toHTML(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          return arg;\n        });\n\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        } // fall back to postfix\n\n\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n\n        var lhsTex = lhs.toTex(options);\n\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n\n        var rhs = args[1]; // right hand side\n\n        var rhsTex = rhs.toTex(options);\n\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        } // handle some exceptions (due to the way LaTeX works)\n\n\n        var lhsIdentifier;\n\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n\n            break;\n\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n\n        }\n\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n\n          return arg;\n        });\n\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n\n\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n\n  }\n\n  _defineProperty(OperatorNode, \"name\", name);\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isConstantNode","isOperatorNode","isParenthesisNode","map","escape","getSafeProperty","isSafeMethod","getAssociativity","getPrecedence","isAssociativeWith","properties","latexOperators","factory","name","dependencies","createOperatorNode","_ref","Node","startsWithConstant","expr","parenthesis","curNode","content","args","calculateNecessaryParentheses","root","implicit","latex","precedence","associativity","length","getIdentifier","arg","getContent","type","result","operandPrecedence","operandIdentifier","rootIdentifier","latexLeftParens","latexParens","lhsParens","lhsPrecedence","assocWithLhs","rhsParens","rhsPrecedence","assocWithRhs","_rootIdentifier","lhsIdentifier","rhsIdentifier","latexRightParens","argPrecedence","assocWithArg","argAssociativity","i","OperatorNode","constructor","op","fn","isPercentage","TypeError","Array","isArray","every","_compile","math","argNames","Error","evalArgs","evalArg0","evalOperatorNode","scope","context","_evalArg","evalArg1","apply","evalArg","forEach","callback","_ifNode","clone","slice","isUnary","isBinary","_toString","options","parens","assoc","operand","toString","opIsNamed","test","lhs","rhs","stringifiedArgs","index","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","lhsTex","rhsTex","texifiedArgs","isClass"],"sources":["/Users/gustavodurcak/node_modules/mathjs/lib/esm/expression/node/OperatorNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isConstantNode, isOperatorNode, isParenthesisNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty, isSafeMethod } from '../../utils/customs.js';\nimport { getAssociativity, getPrecedence, isAssociativeWith, properties } from '../operators.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'OperatorNode';\nvar dependencies = ['Node'];\nexport var createOperatorNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * Returns true if the expression starts with a constant, under\n   * the current parenthesization:\n   * @param {Node} expression\n   * @param {string} parenthesis\n   * @return {boolean}\n   */\n  function startsWithConstant(expr, parenthesis) {\n    var curNode = expr;\n\n    if (parenthesis === 'auto') {\n      while (isParenthesisNode(curNode)) {\n        curNode = curNode.content;\n      }\n    }\n\n    if (isConstantNode(curNode)) return true;\n\n    if (isOperatorNode(curNode)) {\n      return startsWithConstant(curNode.args[0], parenthesis);\n    }\n\n    return false;\n  }\n  /**\n   * Calculate which parentheses are necessary. Gets an OperatorNode\n   * (which is the root of the tree) and an Array of Nodes\n   * (this.args) and returns an array where 'true' means that an argument\n   * has to be enclosed in parentheses whereas 'false' means the opposite.\n   *\n   * @param {OperatorNode} root\n   * @param {string} parenthesis\n   * @param {Node[]} args\n   * @param {boolean} latex\n   * @return {boolean[]}\n   * @private\n   */\n\n\n  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {\n    // precedence of the root OperatorNode\n    var precedence = getPrecedence(root, parenthesis, implicit);\n    var associativity = getAssociativity(root, parenthesis);\n\n    if (parenthesis === 'all' || args.length > 2 && root.getIdentifier() !== 'OperatorNode:add' && root.getIdentifier() !== 'OperatorNode:multiply') {\n      return args.map(function (arg) {\n        switch (arg.getContent().type) {\n          // Nodes that don't need extra parentheses\n          case 'ArrayNode':\n          case 'ConstantNode':\n          case 'SymbolNode':\n          case 'ParenthesisNode':\n            return false;\n\n          default:\n            return true;\n        }\n      });\n    }\n\n    var result;\n\n    switch (args.length) {\n      case 0:\n        result = [];\n        break;\n\n      case 1:\n        // unary operators\n        {\n          // precedence of the operand\n          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n          if (latex && operandPrecedence !== null) {\n            var operandIdentifier;\n            var rootIdentifier;\n\n            if (parenthesis === 'keep') {\n              operandIdentifier = args[0].getIdentifier();\n              rootIdentifier = root.getIdentifier();\n            } else {\n              // Ignore Parenthesis Nodes when not in 'keep' mode\n              operandIdentifier = args[0].getContent().getIdentifier();\n              rootIdentifier = root.getContent().getIdentifier();\n            }\n\n            if (properties[precedence][rootIdentifier].latexLeftParens === false) {\n              result = [false];\n              break;\n            }\n\n            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {\n              result = [false];\n              break;\n            }\n          }\n\n          if (operandPrecedence === null) {\n            // if the operand has no defined precedence, no parens are needed\n            result = [false];\n            break;\n          }\n\n          if (operandPrecedence <= precedence) {\n            // if the operands precedence is lower, parens are needed\n            result = [true];\n            break;\n          } // otherwise, no parens needed\n\n\n          result = [false];\n        }\n        break;\n\n      case 2:\n        // binary operators\n        {\n          var lhsParens; // left hand side needs parenthesis?\n          // precedence of the left hand side\n\n          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root); // is the root node associative with the left hand side\n\n          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);\n\n          if (lhsPrecedence === null) {\n            // if the left hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            lhsParens = false;\n          } else if (lhsPrecedence === precedence && associativity === 'right' && !assocWithLhs) {\n            // In case of equal precedence, if the root node is left associative\n            // parens are **never** necessary for the left hand side.\n            // If it is right associative however, parens are necessary\n            // if the root node isn't associative with the left hand side\n            lhsParens = true;\n          } else if (lhsPrecedence < precedence) {\n            lhsParens = true;\n          } else {\n            lhsParens = false;\n          }\n\n          var rhsParens; // right hand side needs parenthesis?\n          // precedence of the right hand side\n\n          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root); // is the root node associative with the right hand side?\n\n          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);\n\n          if (rhsPrecedence === null) {\n            // if the right hand side has no defined precedence, no parens are needed\n            // FunctionNode for example\n            rhsParens = false;\n          } else if (rhsPrecedence === precedence && associativity === 'left' && !assocWithRhs) {\n            // In case of equal precedence, if the root node is right associative\n            // parens are **never** necessary for the right hand side.\n            // If it is left associative however, parens are necessary\n            // if the root node isn't associative with the right hand side\n            rhsParens = true;\n          } else if (rhsPrecedence < precedence) {\n            rhsParens = true;\n          } else {\n            rhsParens = false;\n          } // handle special cases for LaTeX, where some of the parentheses aren't needed\n\n\n          if (latex) {\n            var _rootIdentifier;\n\n            var lhsIdentifier;\n            var rhsIdentifier;\n\n            if (parenthesis === 'keep') {\n              _rootIdentifier = root.getIdentifier();\n              lhsIdentifier = root.args[0].getIdentifier();\n              rhsIdentifier = root.args[1].getIdentifier();\n            } else {\n              // Ignore ParenthesisNodes when not in 'keep' mode\n              _rootIdentifier = root.getContent().getIdentifier();\n              lhsIdentifier = root.args[0].getContent().getIdentifier();\n              rhsIdentifier = root.args[1].getContent().getIdentifier();\n            }\n\n            if (lhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {\n                lhsParens = false;\n              }\n\n              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {\n                lhsParens = false;\n              }\n            }\n\n            if (rhsPrecedence !== null) {\n              if (properties[precedence][_rootIdentifier].latexRightParens === false) {\n                rhsParens = false;\n              }\n\n              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {\n                rhsParens = false;\n              }\n            }\n          }\n\n          result = [lhsParens, rhsParens];\n        }\n        break;\n\n      default:\n        if (root.getIdentifier() === 'OperatorNode:add' || root.getIdentifier() === 'OperatorNode:multiply') {\n          result = args.map(function (arg) {\n            var argPrecedence = getPrecedence(arg, parenthesis, implicit, root);\n            var assocWithArg = isAssociativeWith(root, arg, parenthesis);\n            var argAssociativity = getAssociativity(arg, parenthesis);\n\n            if (argPrecedence === null) {\n              // if the argument has no defined precedence, no parens are needed\n              return false;\n            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {\n              return true;\n            } else if (argPrecedence < precedence) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n\n        break;\n    } // Handles an edge case of parentheses with implicit multiplication\n    // of ConstantNode.\n    // In that case, parenthesize ConstantNodes that follow an unparenthesized\n    // expression, even though they normally wouldn't be printed.\n\n\n    if (args.length >= 2 && root.getIdentifier() === 'OperatorNode:multiply' && root.implicit && parenthesis !== 'all' && implicit === 'hide') {\n      for (var i = 1; i < result.length; ++i) {\n        if (startsWithConstant(args[i], parenthesis) && !result[i - 1] && (parenthesis !== 'keep' || !isParenthesisNode(args[i - 1]))) {\n          result[i] = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  class OperatorNode extends Node {\n    /**\n     * @constructor OperatorNode\n     * @extends {Node}\n     * An operator with two arguments, like 2+3\n     *\n     * @param {string} op           Operator name, for example '+'\n     * @param {string} fn           Function name, for example 'add'\n     * @param {Node[]} args         Operator arguments\n     * @param {boolean} [implicit]  Is this an implicit multiplication?\n     * @param {boolean} [isPercentage] Is this an percentage Operation?\n     */\n    constructor(op, fn, args, implicit, isPercentage) {\n      super(); // validate input\n\n      if (typeof op !== 'string') {\n        throw new TypeError('string expected for parameter \"op\"');\n      }\n\n      if (typeof fn !== 'string') {\n        throw new TypeError('string expected for parameter \"fn\"');\n      }\n\n      if (!Array.isArray(args) || !args.every(isNode)) {\n        throw new TypeError('Array containing Nodes expected for parameter \"args\"');\n      }\n\n      this.implicit = implicit === true;\n      this.isPercentage = isPercentage === true;\n      this.op = op;\n      this.fn = fn;\n      this.args = args || [];\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isOperatorNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      // validate fn\n      if (typeof this.fn !== 'string' || !isSafeMethod(math, this.fn)) {\n        if (!math[this.fn]) {\n          throw new Error('Function ' + this.fn + ' missing in provided namespace \"math\"');\n        } else {\n          throw new Error('No access to function \"' + this.fn + '\"');\n        }\n      }\n\n      var fn = getSafeProperty(math, this.fn);\n      var evalArgs = map(this.args, function (arg) {\n        return arg._compile(math, argNames);\n      });\n\n      if (evalArgs.length === 1) {\n        var evalArg0 = evalArgs[0];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(evalArg0(scope, args, context));\n        };\n      } else if (evalArgs.length === 2) {\n        var _evalArg = evalArgs[0];\n        var evalArg1 = evalArgs[1];\n        return function evalOperatorNode(scope, args, context) {\n          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));\n        };\n      } else {\n        return function evalOperatorNode(scope, args, context) {\n          return fn.apply(null, map(evalArgs, function (evalArg) {\n            return evalArg(scope, args, context);\n          }));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.args.length; i++) {\n        callback(this.args[i], 'args[' + i + ']', this);\n      }\n    }\n    /**\n     * Create a new OperatorNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {OperatorNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      var args = [];\n\n      for (var i = 0; i < this.args.length; i++) {\n        args[i] = this._ifNode(callback(this.args[i], 'args[' + i + ']', this));\n      }\n\n      return new OperatorNode(this.op, this.fn, args, this.implicit, this.isPercentage);\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {OperatorNode}\n     */\n\n\n    clone() {\n      return new OperatorNode(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);\n    }\n    /**\n     * Check whether this is an unary OperatorNode:\n     * has exactly one argument, like `-a`.\n     * @return {boolean}\n     *     Returns true when an unary operator node, false otherwise.\n     */\n\n\n    isUnary() {\n      return this.args.length === 1;\n    }\n    /**\n     * Check whether this is a binary OperatorNode:\n     * has exactly two arguments, like `a + b`.\n     * @return {boolean}\n     *     Returns true when a binary operator node, false otherwise.\n     */\n\n\n    isBinary() {\n      return this.args.length === 2;\n    }\n    /**\n     * Get string representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toString(options);\n\n        if (parens[0]) {\n          operand = '(' + operand + ')';\n        } // for example for \"not\", we want a space between operand and argument\n\n\n        var opIsNamed = /[a-zA-Z]+/.test(this.op);\n\n        if (assoc === 'right') {\n          // prefix operator\n          return this.op + (opIsNamed ? ' ' : '') + operand;\n        } else if (assoc === 'left') {\n          // postfix\n          return operand + (opIsNamed ? ' ' : '') + this.op;\n        } // fall back to postfix\n\n\n        return operand + this.op;\n      } else if (args.length === 2) {\n        var lhs = args[0].toString(options); // left hand side\n\n        var rhs = args[1].toString(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '(' + lhs + ')';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '(' + rhs + ')';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + ' ' + rhs;\n        }\n\n        return lhs + ' ' + this.op + ' ' + rhs;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toString(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '(' + arg + ')';\n          }\n\n          return arg;\n        });\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return stringifiedArgs.join(' ');\n        }\n\n        return stringifiedArgs.join(' ' + this.op + ' ');\n      } else {\n        // fallback to formatting as a function call\n        return this.fn + '(' + this.args.join(', ') + ')';\n      }\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        op: this.op,\n        fn: this.fn,\n        args: this.args,\n        implicit: this.implicit,\n        isPercentage: this.isPercentage\n      };\n    }\n    /**\n     * Instantiate an OperatorNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"OperatorNode\",\n     *      \"op\": \"+\", \"fn\": \"add\", \"args\": [...],\n     *      \"implicit\": false,\n     *      \"isPercentage\":false}\n     *     ```\n     *     where mathjs is optional\n     * @returns {OperatorNode}\n     */\n\n\n    static fromJSON(json) {\n      return new OperatorNode(json.op, json.fn, json.args, json.implicit, json.isPercentage);\n    }\n    /**\n     * Get HTML representation.\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toHTML(options);\n\n        if (parens[0]) {\n          operand = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + operand + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return '<span class=\"math-operator math-unary-operator ' + 'math-lefthand-unary-operator\">' + escape(this.op) + '</span>' + operand;\n        } else {\n          // postfix when assoc === 'left' or undefined\n          return operand + '<span class=\"math-operator math-unary-operator ' + 'math-righthand-unary-operator\">' + escape(this.op) + '</span>';\n        }\n      } else if (args.length === 2) {\n        // binary operatoes\n        var lhs = args[0].toHTML(options); // left hand side\n\n        var rhs = args[1].toHTML(options); // right hand side\n\n        if (parens[0]) {\n          // left hand side in parenthesis?\n          lhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + lhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (parens[1]) {\n          // right hand side in parenthesis?\n          rhs = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + rhs + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n          return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>' + rhs;\n        }\n\n        return lhs + '<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>' + rhs;\n      } else {\n        var stringifiedArgs = args.map(function (arg, index) {\n          arg = arg.toHTML(options);\n\n          if (parens[index]) {\n            // put in parenthesis?\n            arg = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + arg + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n          }\n\n          return arg;\n        });\n\n        if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n          if (this.implicit && this.getIdentifier() === 'OperatorNode:multiply' && implicit === 'hide') {\n            return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-implicit-binary-operator\"></span>');\n          }\n\n          return stringifiedArgs.join('<span class=\"math-operator math-binary-operator ' + 'math-explicit-binary-operator\">' + escape(this.op) + '</span>');\n        } else {\n          // fallback to formatting as a function call\n          return '<span class=\"math-function\">' + escape(this.fn) + '</span><span class=\"math-paranthesis math-round-parenthesis\">' + '(</span>' + stringifiedArgs.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-paranthesis math-round-parenthesis\">)</span>';\n        }\n      }\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var implicit = options && options.implicit ? options.implicit : 'hide';\n      var args = this.args;\n      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);\n      var op = latexOperators[this.fn];\n      op = typeof op === 'undefined' ? this.op : op; // fall back to using this.op\n\n      if (args.length === 1) {\n        // unary operators\n        var assoc = getAssociativity(this, parenthesis);\n        var operand = args[0].toTex(options);\n\n        if (parens[0]) {\n          operand = \"\\\\left(\".concat(operand, \"\\\\right)\");\n        }\n\n        if (assoc === 'right') {\n          // prefix operator\n          return op + operand;\n        } else if (assoc === 'left') {\n          // postfix operator\n          return operand + op;\n        } // fall back to postfix\n\n\n        return operand + op;\n      } else if (args.length === 2) {\n        // binary operators\n        var lhs = args[0]; // left hand side\n\n        var lhsTex = lhs.toTex(options);\n\n        if (parens[0]) {\n          lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n        }\n\n        var rhs = args[1]; // right hand side\n\n        var rhsTex = rhs.toTex(options);\n\n        if (parens[1]) {\n          rhsTex = \"\\\\left(\".concat(rhsTex, \"\\\\right)\");\n        } // handle some exceptions (due to the way LaTeX works)\n\n\n        var lhsIdentifier;\n\n        if (parenthesis === 'keep') {\n          lhsIdentifier = lhs.getIdentifier();\n        } else {\n          // Ignore ParenthesisNodes if in 'keep' mode\n          lhsIdentifier = lhs.getContent().getIdentifier();\n        }\n\n        switch (this.getIdentifier()) {\n          case 'OperatorNode:divide':\n            // op contains '\\\\frac' at this point\n            return op + '{' + lhsTex + '}' + '{' + rhsTex + '}';\n\n          case 'OperatorNode:pow':\n            lhsTex = '{' + lhsTex + '}';\n            rhsTex = '{' + rhsTex + '}';\n\n            switch (lhsIdentifier) {\n              case 'ConditionalNode': //\n\n              case 'OperatorNode:divide':\n                lhsTex = \"\\\\left(\".concat(lhsTex, \"\\\\right)\");\n            }\n\n            break;\n\n          case 'OperatorNode:multiply':\n            if (this.implicit && implicit === 'hide') {\n              return lhsTex + '~' + rhsTex;\n            }\n\n        }\n\n        return lhsTex + op + rhsTex;\n      } else if (args.length > 2 && (this.getIdentifier() === 'OperatorNode:add' || this.getIdentifier() === 'OperatorNode:multiply')) {\n        var texifiedArgs = args.map(function (arg, index) {\n          arg = arg.toTex(options);\n\n          if (parens[index]) {\n            arg = \"\\\\left(\".concat(arg, \"\\\\right)\");\n          }\n\n          return arg;\n        });\n\n        if (this.getIdentifier() === 'OperatorNode:multiply' && this.implicit && implicit === 'hide') {\n          return texifiedArgs.join('~');\n        }\n\n        return texifiedArgs.join(op);\n      } else {\n        // fall back to formatting as a function call\n        // as this is a fallback, it doesn't use\n        // fancy function names\n        return '\\\\mathrm{' + this.fn + '}\\\\left(' + args.map(function (arg) {\n          return arg.toTex(options);\n        }).join(',') + '\\\\right)';\n      }\n    }\n    /**\n     * Get identifier.\n     * @return {string}\n     */\n\n\n    getIdentifier() {\n      return this.type + ':' + this.fn;\n    }\n\n  }\n\n  _defineProperty(OperatorNode, \"name\", name);\n\n  return OperatorNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,uCAA5B;AACA,SAASC,MAAT,EAAiBC,cAAjB,EAAiCC,cAAjC,EAAiDC,iBAAjD,QAA0E,mBAA1E;AACA,SAASC,GAAT,QAAoB,sBAApB;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,eAAT,EAA0BC,YAA1B,QAA8C,wBAA9C;AACA,SAASC,gBAAT,EAA2BC,aAA3B,EAA0CC,iBAA1C,EAA6DC,UAA7D,QAA+E,iBAA/E;AACA,SAASC,cAAT,QAA+B,sBAA/B;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,IAAIC,IAAI,GAAG,cAAX;AACA,IAAIC,YAAY,GAAG,CAAC,MAAD,CAAnB;AACA,OAAO,IAAIC,kBAAkB,GAAG,eAAeH,OAAO,CAACC,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;EACjF,IAAI;IACFC;EADE,IAEAD,IAFJ;EAIA;AACF;AACA;AACA;AACA;AACA;AACA;;EACE,SAASE,kBAAT,CAA4BC,IAA5B,EAAkCC,WAAlC,EAA+C;IAC7C,IAAIC,OAAO,GAAGF,IAAd;;IAEA,IAAIC,WAAW,KAAK,MAApB,EAA4B;MAC1B,OAAOlB,iBAAiB,CAACmB,OAAD,CAAxB,EAAmC;QACjCA,OAAO,GAAGA,OAAO,CAACC,OAAlB;MACD;IACF;;IAED,IAAItB,cAAc,CAACqB,OAAD,CAAlB,EAA6B,OAAO,IAAP;;IAE7B,IAAIpB,cAAc,CAACoB,OAAD,CAAlB,EAA6B;MAC3B,OAAOH,kBAAkB,CAACG,OAAO,CAACE,IAAR,CAAa,CAAb,CAAD,EAAkBH,WAAlB,CAAzB;IACD;;IAED,OAAO,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASI,6BAAT,CAAuCC,IAAvC,EAA6CL,WAA7C,EAA0DM,QAA1D,EAAoEH,IAApE,EAA0EI,KAA1E,EAAiF;IAC/E;IACA,IAAIC,UAAU,GAAGpB,aAAa,CAACiB,IAAD,EAAOL,WAAP,EAAoBM,QAApB,CAA9B;IACA,IAAIG,aAAa,GAAGtB,gBAAgB,CAACkB,IAAD,EAAOL,WAAP,CAApC;;IAEA,IAAIA,WAAW,KAAK,KAAhB,IAAyBG,IAAI,CAACO,MAAL,GAAc,CAAd,IAAmBL,IAAI,CAACM,aAAL,OAAyB,kBAA5C,IAAkEN,IAAI,CAACM,aAAL,OAAyB,uBAAxH,EAAiJ;MAC/I,OAAOR,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe;QAC7B,QAAQA,GAAG,CAACC,UAAJ,GAAiBC,IAAzB;UACE;UACA,KAAK,WAAL;UACA,KAAK,cAAL;UACA,KAAK,YAAL;UACA,KAAK,iBAAL;YACE,OAAO,KAAP;;UAEF;YACE,OAAO,IAAP;QATJ;MAWD,CAZM,CAAP;IAaD;;IAED,IAAIC,MAAJ;;IAEA,QAAQZ,IAAI,CAACO,MAAb;MACE,KAAK,CAAL;QACEK,MAAM,GAAG,EAAT;QACA;;MAEF,KAAK,CAAL;QACE;QACA;UACE;UACA,IAAIC,iBAAiB,GAAG5B,aAAa,CAACe,IAAI,CAAC,CAAD,CAAL,EAAUH,WAAV,EAAuBM,QAAvB,EAAiCD,IAAjC,CAArC,CAFF,CAE+E;;UAE7E,IAAIE,KAAK,IAAIS,iBAAiB,KAAK,IAAnC,EAAyC;YACvC,IAAIC,iBAAJ;YACA,IAAIC,cAAJ;;YAEA,IAAIlB,WAAW,KAAK,MAApB,EAA4B;cAC1BiB,iBAAiB,GAAGd,IAAI,CAAC,CAAD,CAAJ,CAAQQ,aAAR,EAApB;cACAO,cAAc,GAAGb,IAAI,CAACM,aAAL,EAAjB;YACD,CAHD,MAGO;cACL;cACAM,iBAAiB,GAAGd,IAAI,CAAC,CAAD,CAAJ,CAAQU,UAAR,GAAqBF,aAArB,EAApB;cACAO,cAAc,GAAGb,IAAI,CAACQ,UAAL,GAAkBF,aAAlB,EAAjB;YACD;;YAED,IAAIrB,UAAU,CAACkB,UAAD,CAAV,CAAuBU,cAAvB,EAAuCC,eAAvC,KAA2D,KAA/D,EAAsE;cACpEJ,MAAM,GAAG,CAAC,KAAD,CAAT;cACA;YACD;;YAED,IAAIzB,UAAU,CAAC0B,iBAAD,CAAV,CAA8BC,iBAA9B,EAAiDG,WAAjD,KAAiE,KAArE,EAA4E;cAC1EL,MAAM,GAAG,CAAC,KAAD,CAAT;cACA;YACD;UACF;;UAED,IAAIC,iBAAiB,KAAK,IAA1B,EAAgC;YAC9B;YACAD,MAAM,GAAG,CAAC,KAAD,CAAT;YACA;UACD;;UAED,IAAIC,iBAAiB,IAAIR,UAAzB,EAAqC;YACnC;YACAO,MAAM,GAAG,CAAC,IAAD,CAAT;YACA;UACD,CAtCH,CAsCI;;;UAGFA,MAAM,GAAG,CAAC,KAAD,CAAT;QACD;QACD;;MAEF,KAAK,CAAL;QACE;QACA;UACE,IAAIM,SAAJ,CADF,CACiB;UACf;;UAEA,IAAIC,aAAa,GAAGlC,aAAa,CAACe,IAAI,CAAC,CAAD,CAAL,EAAUH,WAAV,EAAuBM,QAAvB,EAAiCD,IAAjC,CAAjC,CAJF,CAI2E;;UAEzE,IAAIkB,YAAY,GAAGlC,iBAAiB,CAACgB,IAAD,EAAOF,IAAI,CAAC,CAAD,CAAX,EAAgBH,WAAhB,CAApC;;UAEA,IAAIsB,aAAa,KAAK,IAAtB,EAA4B;YAC1B;YACA;YACAD,SAAS,GAAG,KAAZ;UACD,CAJD,MAIO,IAAIC,aAAa,KAAKd,UAAlB,IAAgCC,aAAa,KAAK,OAAlD,IAA6D,CAACc,YAAlE,EAAgF;YACrF;YACA;YACA;YACA;YACAF,SAAS,GAAG,IAAZ;UACD,CANM,MAMA,IAAIC,aAAa,GAAGd,UAApB,EAAgC;YACrCa,SAAS,GAAG,IAAZ;UACD,CAFM,MAEA;YACLA,SAAS,GAAG,KAAZ;UACD;;UAED,IAAIG,SAAJ,CAxBF,CAwBiB;UACf;;UAEA,IAAIC,aAAa,GAAGrC,aAAa,CAACe,IAAI,CAAC,CAAD,CAAL,EAAUH,WAAV,EAAuBM,QAAvB,EAAiCD,IAAjC,CAAjC,CA3BF,CA2B2E;;UAEzE,IAAIqB,YAAY,GAAGrC,iBAAiB,CAACgB,IAAD,EAAOF,IAAI,CAAC,CAAD,CAAX,EAAgBH,WAAhB,CAApC;;UAEA,IAAIyB,aAAa,KAAK,IAAtB,EAA4B;YAC1B;YACA;YACAD,SAAS,GAAG,KAAZ;UACD,CAJD,MAIO,IAAIC,aAAa,KAAKjB,UAAlB,IAAgCC,aAAa,KAAK,MAAlD,IAA4D,CAACiB,YAAjE,EAA+E;YACpF;YACA;YACA;YACA;YACAF,SAAS,GAAG,IAAZ;UACD,CANM,MAMA,IAAIC,aAAa,GAAGjB,UAApB,EAAgC;YACrCgB,SAAS,GAAG,IAAZ;UACD,CAFM,MAEA;YACLA,SAAS,GAAG,KAAZ;UACD,CA7CH,CA6CI;;;UAGF,IAAIjB,KAAJ,EAAW;YACT,IAAIoB,eAAJ;;YAEA,IAAIC,aAAJ;YACA,IAAIC,aAAJ;;YAEA,IAAI7B,WAAW,KAAK,MAApB,EAA4B;cAC1B2B,eAAe,GAAGtB,IAAI,CAACM,aAAL,EAAlB;cACAiB,aAAa,GAAGvB,IAAI,CAACF,IAAL,CAAU,CAAV,EAAaQ,aAAb,EAAhB;cACAkB,aAAa,GAAGxB,IAAI,CAACF,IAAL,CAAU,CAAV,EAAaQ,aAAb,EAAhB;YACD,CAJD,MAIO;cACL;cACAgB,eAAe,GAAGtB,IAAI,CAACQ,UAAL,GAAkBF,aAAlB,EAAlB;cACAiB,aAAa,GAAGvB,IAAI,CAACF,IAAL,CAAU,CAAV,EAAaU,UAAb,GAA0BF,aAA1B,EAAhB;cACAkB,aAAa,GAAGxB,IAAI,CAACF,IAAL,CAAU,CAAV,EAAaU,UAAb,GAA0BF,aAA1B,EAAhB;YACD;;YAED,IAAIW,aAAa,KAAK,IAAtB,EAA4B;cAC1B,IAAIhC,UAAU,CAACkB,UAAD,CAAV,CAAuBmB,eAAvB,EAAwCR,eAAxC,KAA4D,KAAhE,EAAuE;gBACrEE,SAAS,GAAG,KAAZ;cACD;;cAED,IAAI/B,UAAU,CAACgC,aAAD,CAAV,CAA0BM,aAA1B,EAAyCR,WAAzC,KAAyD,KAA7D,EAAoE;gBAClEC,SAAS,GAAG,KAAZ;cACD;YACF;;YAED,IAAII,aAAa,KAAK,IAAtB,EAA4B;cAC1B,IAAInC,UAAU,CAACkB,UAAD,CAAV,CAAuBmB,eAAvB,EAAwCG,gBAAxC,KAA6D,KAAjE,EAAwE;gBACtEN,SAAS,GAAG,KAAZ;cACD;;cAED,IAAIlC,UAAU,CAACmC,aAAD,CAAV,CAA0BI,aAA1B,EAAyCT,WAAzC,KAAyD,KAA7D,EAAoE;gBAClEI,SAAS,GAAG,KAAZ;cACD;YACF;UACF;;UAEDT,MAAM,GAAG,CAACM,SAAD,EAAYG,SAAZ,CAAT;QACD;QACD;;MAEF;QACE,IAAInB,IAAI,CAACM,aAAL,OAAyB,kBAAzB,IAA+CN,IAAI,CAACM,aAAL,OAAyB,uBAA5E,EAAqG;UACnGI,MAAM,GAAGZ,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe;YAC/B,IAAImB,aAAa,GAAG3C,aAAa,CAACwB,GAAD,EAAMZ,WAAN,EAAmBM,QAAnB,EAA6BD,IAA7B,CAAjC;YACA,IAAI2B,YAAY,GAAG3C,iBAAiB,CAACgB,IAAD,EAAOO,GAAP,EAAYZ,WAAZ,CAApC;YACA,IAAIiC,gBAAgB,GAAG9C,gBAAgB,CAACyB,GAAD,EAAMZ,WAAN,CAAvC;;YAEA,IAAI+B,aAAa,KAAK,IAAtB,EAA4B;cAC1B;cACA,OAAO,KAAP;YACD,CAHD,MAGO,IAAIvB,UAAU,KAAKuB,aAAf,IAAgCtB,aAAa,KAAKwB,gBAAlD,IAAsE,CAACD,YAA3E,EAAyF;cAC9F,OAAO,IAAP;YACD,CAFM,MAEA,IAAID,aAAa,GAAGvB,UAApB,EAAgC;cACrC,OAAO,IAAP;YACD;;YAED,OAAO,KAAP;UACD,CAfQ,CAAT;QAgBD;;QAED;IApKJ,CAvB+E,CA4L7E;IACF;IACA;IACA;;;IAGA,IAAIL,IAAI,CAACO,MAAL,IAAe,CAAf,IAAoBL,IAAI,CAACM,aAAL,OAAyB,uBAA7C,IAAwEN,IAAI,CAACC,QAA7E,IAAyFN,WAAW,KAAK,KAAzG,IAAkHM,QAAQ,KAAK,MAAnI,EAA2I;MACzI,KAAK,IAAI4B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,MAAM,CAACL,MAA3B,EAAmC,EAAEwB,CAArC,EAAwC;QACtC,IAAIpC,kBAAkB,CAACK,IAAI,CAAC+B,CAAD,CAAL,EAAUlC,WAAV,CAAlB,IAA4C,CAACe,MAAM,CAACmB,CAAC,GAAG,CAAL,CAAnD,KAA+DlC,WAAW,KAAK,MAAhB,IAA0B,CAAClB,iBAAiB,CAACqB,IAAI,CAAC+B,CAAC,GAAG,CAAL,CAAL,CAA3G,CAAJ,EAA+H;UAC7HnB,MAAM,CAACmB,CAAD,CAAN,GAAY,IAAZ;QACD;MACF;IACF;;IAED,OAAOnB,MAAP;EACD;;EAED,MAAMoB,YAAN,SAA2BtC,IAA3B,CAAgC;IAC9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIuC,WAAW,CAACC,EAAD,EAAKC,EAAL,EAASnC,IAAT,EAAeG,QAAf,EAAyBiC,YAAzB,EAAuC;MAChD,QADgD,CACvC;;MAET,IAAI,OAAOF,EAAP,KAAc,QAAlB,EAA4B;QAC1B,MAAM,IAAIG,SAAJ,CAAc,oCAAd,CAAN;MACD;;MAED,IAAI,OAAOF,EAAP,KAAc,QAAlB,EAA4B;QAC1B,MAAM,IAAIE,SAAJ,CAAc,oCAAd,CAAN;MACD;;MAED,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcvC,IAAd,CAAD,IAAwB,CAACA,IAAI,CAACwC,KAAL,CAAWhE,MAAX,CAA7B,EAAiD;QAC/C,MAAM,IAAI6D,SAAJ,CAAc,sDAAd,CAAN;MACD;;MAED,KAAKlC,QAAL,GAAgBA,QAAQ,KAAK,IAA7B;MACA,KAAKiC,YAAL,GAAoBA,YAAY,KAAK,IAArC;MACA,KAAKF,EAAL,GAAUA,EAAV;MACA,KAAKC,EAAL,GAAUA,EAAV;MACA,KAAKnC,IAAL,GAAYA,IAAI,IAAI,EAApB;IACD;;IAEO,IAAJW,IAAI,GAAG;MACT,OAAOrB,IAAP;IACD;;IAEiB,IAAdZ,cAAc,GAAG;MACnB,OAAO,IAAP;IACD;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGI+D,QAAQ,CAACC,IAAD,EAAOC,QAAP,EAAiB;MACvB;MACA,IAAI,OAAO,KAAKR,EAAZ,KAAmB,QAAnB,IAA+B,CAACpD,YAAY,CAAC2D,IAAD,EAAO,KAAKP,EAAZ,CAAhD,EAAiE;QAC/D,IAAI,CAACO,IAAI,CAAC,KAAKP,EAAN,CAAT,EAAoB;UAClB,MAAM,IAAIS,KAAJ,CAAU,cAAc,KAAKT,EAAnB,GAAwB,uCAAlC,CAAN;QACD,CAFD,MAEO;UACL,MAAM,IAAIS,KAAJ,CAAU,4BAA4B,KAAKT,EAAjC,GAAsC,GAAhD,CAAN;QACD;MACF;;MAED,IAAIA,EAAE,GAAGrD,eAAe,CAAC4D,IAAD,EAAO,KAAKP,EAAZ,CAAxB;MACA,IAAIU,QAAQ,GAAGjE,GAAG,CAAC,KAAKoB,IAAN,EAAY,UAAUS,GAAV,EAAe;QAC3C,OAAOA,GAAG,CAACgC,QAAJ,CAAaC,IAAb,EAAmBC,QAAnB,CAAP;MACD,CAFiB,CAAlB;;MAIA,IAAIE,QAAQ,CAACtC,MAAT,KAAoB,CAAxB,EAA2B;QACzB,IAAIuC,QAAQ,GAAGD,QAAQ,CAAC,CAAD,CAAvB;QACA,OAAO,SAASE,gBAAT,CAA0BC,KAA1B,EAAiChD,IAAjC,EAAuCiD,OAAvC,EAAgD;UACrD,OAAOd,EAAE,CAACW,QAAQ,CAACE,KAAD,EAAQhD,IAAR,EAAciD,OAAd,CAAT,CAAT;QACD,CAFD;MAGD,CALD,MAKO,IAAIJ,QAAQ,CAACtC,MAAT,KAAoB,CAAxB,EAA2B;QAChC,IAAI2C,QAAQ,GAAGL,QAAQ,CAAC,CAAD,CAAvB;QACA,IAAIM,QAAQ,GAAGN,QAAQ,CAAC,CAAD,CAAvB;QACA,OAAO,SAASE,gBAAT,CAA0BC,KAA1B,EAAiChD,IAAjC,EAAuCiD,OAAvC,EAAgD;UACrD,OAAOd,EAAE,CAACe,QAAQ,CAACF,KAAD,EAAQhD,IAAR,EAAciD,OAAd,CAAT,EAAiCE,QAAQ,CAACH,KAAD,EAAQhD,IAAR,EAAciD,OAAd,CAAzC,CAAT;QACD,CAFD;MAGD,CANM,MAMA;QACL,OAAO,SAASF,gBAAT,CAA0BC,KAA1B,EAAiChD,IAAjC,EAAuCiD,OAAvC,EAAgD;UACrD,OAAOd,EAAE,CAACiB,KAAH,CAAS,IAAT,EAAexE,GAAG,CAACiE,QAAD,EAAW,UAAUQ,OAAV,EAAmB;YACrD,OAAOA,OAAO,CAACL,KAAD,EAAQhD,IAAR,EAAciD,OAAd,CAAd;UACD,CAFwB,CAAlB,CAAP;QAGD,CAJD;MAKD;IACF;IACD;AACJ;AACA;AACA;;;IAGIK,OAAO,CAACC,QAAD,EAAW;MAChB,KAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK/B,IAAL,CAAUO,MAA9B,EAAsCwB,CAAC,EAAvC,EAA2C;QACzCwB,QAAQ,CAAC,KAAKvD,IAAL,CAAU+B,CAAV,CAAD,EAAe,UAAUA,CAAV,GAAc,GAA7B,EAAkC,IAAlC,CAAR;MACD;IACF;IACD;AACJ;AACA;AACA;AACA;AACA;;;IAGInD,GAAG,CAAC2E,QAAD,EAAW;MACZ,IAAIvD,IAAI,GAAG,EAAX;;MAEA,KAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAK/B,IAAL,CAAUO,MAA9B,EAAsCwB,CAAC,EAAvC,EAA2C;QACzC/B,IAAI,CAAC+B,CAAD,CAAJ,GAAU,KAAKyB,OAAL,CAAaD,QAAQ,CAAC,KAAKvD,IAAL,CAAU+B,CAAV,CAAD,EAAe,UAAUA,CAAV,GAAc,GAA7B,EAAkC,IAAlC,CAArB,CAAV;MACD;;MAED,OAAO,IAAIC,YAAJ,CAAiB,KAAKE,EAAtB,EAA0B,KAAKC,EAA/B,EAAmCnC,IAAnC,EAAyC,KAAKG,QAA9C,EAAwD,KAAKiC,YAA7D,CAAP;IACD;IACD;AACJ;AACA;AACA;;;IAGIqB,KAAK,GAAG;MACN,OAAO,IAAIzB,YAAJ,CAAiB,KAAKE,EAAtB,EAA0B,KAAKC,EAA/B,EAAmC,KAAKnC,IAAL,CAAU0D,KAAV,CAAgB,CAAhB,CAAnC,EAAuD,KAAKvD,QAA5D,EAAsE,KAAKiC,YAA3E,CAAP;IACD;IACD;AACJ;AACA;AACA;AACA;AACA;;;IAGIuB,OAAO,GAAG;MACR,OAAO,KAAK3D,IAAL,CAAUO,MAAV,KAAqB,CAA5B;IACD;IACD;AACJ;AACA;AACA;AACA;AACA;;;IAGIqD,QAAQ,GAAG;MACT,OAAO,KAAK5D,IAAL,CAAUO,MAAV,KAAqB,CAA5B;IACD;IACD;AACJ;AACA;AACA;AACA;;;IAGIsD,SAAS,CAACC,OAAD,EAAU;MACjB,IAAIjE,WAAW,GAAGiE,OAAO,IAAIA,OAAO,CAACjE,WAAnB,GAAiCiE,OAAO,CAACjE,WAAzC,GAAuD,MAAzE;MACA,IAAIM,QAAQ,GAAG2D,OAAO,IAAIA,OAAO,CAAC3D,QAAnB,GAA8B2D,OAAO,CAAC3D,QAAtC,GAAiD,MAAhE;MACA,IAAIH,IAAI,GAAG,KAAKA,IAAhB;MACA,IAAI+D,MAAM,GAAG9D,6BAA6B,CAAC,IAAD,EAAOJ,WAAP,EAAoBM,QAApB,EAA8BH,IAA9B,EAAoC,KAApC,CAA1C;;MAEA,IAAIA,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QACrB;QACA,IAAIyD,KAAK,GAAGhF,gBAAgB,CAAC,IAAD,EAAOa,WAAP,CAA5B;QACA,IAAIoE,OAAO,GAAGjE,IAAI,CAAC,CAAD,CAAJ,CAAQkE,QAAR,CAAiBJ,OAAjB,CAAd;;QAEA,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACbE,OAAO,GAAG,MAAMA,OAAN,GAAgB,GAA1B;QACD,CAPoB,CAOnB;;;QAGF,IAAIE,SAAS,GAAG,YAAYC,IAAZ,CAAiB,KAAKlC,EAAtB,CAAhB;;QAEA,IAAI8B,KAAK,KAAK,OAAd,EAAuB;UACrB;UACA,OAAO,KAAK9B,EAAL,IAAWiC,SAAS,GAAG,GAAH,GAAS,EAA7B,IAAmCF,OAA1C;QACD,CAHD,MAGO,IAAID,KAAK,KAAK,MAAd,EAAsB;UAC3B;UACA,OAAOC,OAAO,IAAIE,SAAS,GAAG,GAAH,GAAS,EAAtB,CAAP,GAAmC,KAAKjC,EAA/C;QACD,CAlBoB,CAkBnB;;;QAGF,OAAO+B,OAAO,GAAG,KAAK/B,EAAtB;MACD,CAtBD,MAsBO,IAAIlC,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QAC5B,IAAI8D,GAAG,GAAGrE,IAAI,CAAC,CAAD,CAAJ,CAAQkE,QAAR,CAAiBJ,OAAjB,CAAV,CAD4B,CACS;;QAErC,IAAIQ,GAAG,GAAGtE,IAAI,CAAC,CAAD,CAAJ,CAAQkE,QAAR,CAAiBJ,OAAjB,CAAV,CAH4B,CAGS;;QAErC,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACb;UACAM,GAAG,GAAG,MAAMA,GAAN,GAAY,GAAlB;QACD;;QAED,IAAIN,MAAM,CAAC,CAAD,CAAV,EAAe;UACb;UACAO,GAAG,GAAG,MAAMA,GAAN,GAAY,GAAlB;QACD;;QAED,IAAI,KAAKnE,QAAL,IAAiB,KAAKK,aAAL,OAAyB,uBAA1C,IAAqEL,QAAQ,KAAK,MAAtF,EAA8F;UAC5F,OAAOkE,GAAG,GAAG,GAAN,GAAYC,GAAnB;QACD;;QAED,OAAOD,GAAG,GAAG,GAAN,GAAY,KAAKnC,EAAjB,GAAsB,GAAtB,GAA4BoC,GAAnC;MACD,CApBM,MAoBA,IAAItE,IAAI,CAACO,MAAL,GAAc,CAAd,KAAoB,KAAKC,aAAL,OAAyB,kBAAzB,IAA+C,KAAKA,aAAL,OAAyB,uBAA5F,CAAJ,EAA0H;QAC/H,IAAI+D,eAAe,GAAGvE,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe+D,KAAf,EAAsB;UACnD/D,GAAG,GAAGA,GAAG,CAACyD,QAAJ,CAAaJ,OAAb,CAAN;;UAEA,IAAIC,MAAM,CAACS,KAAD,CAAV,EAAmB;YACjB;YACA/D,GAAG,GAAG,MAAMA,GAAN,GAAY,GAAlB;UACD;;UAED,OAAOA,GAAP;QACD,CATqB,CAAtB;;QAWA,IAAI,KAAKN,QAAL,IAAiB,KAAKK,aAAL,OAAyB,uBAA1C,IAAqEL,QAAQ,KAAK,MAAtF,EAA8F;UAC5F,OAAOoE,eAAe,CAACE,IAAhB,CAAqB,GAArB,CAAP;QACD;;QAED,OAAOF,eAAe,CAACE,IAAhB,CAAqB,MAAM,KAAKvC,EAAX,GAAgB,GAArC,CAAP;MACD,CAjBM,MAiBA;QACL;QACA,OAAO,KAAKC,EAAL,GAAU,GAAV,GAAgB,KAAKnC,IAAL,CAAUyE,IAAV,CAAe,IAAf,CAAhB,GAAuC,GAA9C;MACD;IACF;IACD;AACJ;AACA;AACA;;;IAGIC,MAAM,GAAG;MACP,OAAO;QACLC,MAAM,EAAErF,IADH;QAEL4C,EAAE,EAAE,KAAKA,EAFJ;QAGLC,EAAE,EAAE,KAAKA,EAHJ;QAILnC,IAAI,EAAE,KAAKA,IAJN;QAKLG,QAAQ,EAAE,KAAKA,QALV;QAMLiC,YAAY,EAAE,KAAKA;MANd,CAAP;IAQD;IACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IAGmB,OAARwC,QAAQ,CAACC,IAAD,EAAO;MACpB,OAAO,IAAI7C,YAAJ,CAAiB6C,IAAI,CAAC3C,EAAtB,EAA0B2C,IAAI,CAAC1C,EAA/B,EAAmC0C,IAAI,CAAC7E,IAAxC,EAA8C6E,IAAI,CAAC1E,QAAnD,EAA6D0E,IAAI,CAACzC,YAAlE,CAAP;IACD;IACD;AACJ;AACA;AACA;AACA;;;IAGI0C,MAAM,CAAChB,OAAD,EAAU;MACd,IAAIjE,WAAW,GAAGiE,OAAO,IAAIA,OAAO,CAACjE,WAAnB,GAAiCiE,OAAO,CAACjE,WAAzC,GAAuD,MAAzE;MACA,IAAIM,QAAQ,GAAG2D,OAAO,IAAIA,OAAO,CAAC3D,QAAnB,GAA8B2D,OAAO,CAAC3D,QAAtC,GAAiD,MAAhE;MACA,IAAIH,IAAI,GAAG,KAAKA,IAAhB;MACA,IAAI+D,MAAM,GAAG9D,6BAA6B,CAAC,IAAD,EAAOJ,WAAP,EAAoBM,QAApB,EAA8BH,IAA9B,EAAoC,KAApC,CAA1C;;MAEA,IAAIA,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QACrB;QACA,IAAIyD,KAAK,GAAGhF,gBAAgB,CAAC,IAAD,EAAOa,WAAP,CAA5B;QACA,IAAIoE,OAAO,GAAGjE,IAAI,CAAC,CAAD,CAAJ,CAAQ8E,MAAR,CAAehB,OAAf,CAAd;;QAEA,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACbE,OAAO,GAAG,mEAAmEA,OAAnE,GAA6E,gEAAvF;QACD;;QAED,IAAID,KAAK,KAAK,OAAd,EAAuB;UACrB;UACA,OAAO,oDAAoD,gCAApD,GAAuFnF,MAAM,CAAC,KAAKqD,EAAN,CAA7F,GAAyG,SAAzG,GAAqH+B,OAA5H;QACD,CAHD,MAGO;UACL;UACA,OAAOA,OAAO,GAAG,iDAAV,GAA8D,iCAA9D,GAAkGpF,MAAM,CAAC,KAAKqD,EAAN,CAAxG,GAAoH,SAA3H;QACD;MACF,CAhBD,MAgBO,IAAIlC,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QAC5B;QACA,IAAI8D,GAAG,GAAGrE,IAAI,CAAC,CAAD,CAAJ,CAAQ8E,MAAR,CAAehB,OAAf,CAAV,CAF4B,CAEO;;QAEnC,IAAIQ,GAAG,GAAGtE,IAAI,CAAC,CAAD,CAAJ,CAAQ8E,MAAR,CAAehB,OAAf,CAAV,CAJ4B,CAIO;;QAEnC,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACb;UACAM,GAAG,GAAG,mEAAmEA,GAAnE,GAAyE,gEAA/E;QACD;;QAED,IAAIN,MAAM,CAAC,CAAD,CAAV,EAAe;UACb;UACAO,GAAG,GAAG,mEAAmEA,GAAnE,GAAyE,gEAA/E;QACD;;QAED,IAAI,KAAKnE,QAAL,IAAiB,KAAKK,aAAL,OAAyB,uBAA1C,IAAqEL,QAAQ,KAAK,MAAtF,EAA8F;UAC5F,OAAOkE,GAAG,GAAG,kDAAN,GAA2D,wCAA3D,GAAsGC,GAA7G;QACD;;QAED,OAAOD,GAAG,GAAG,kDAAN,GAA2D,iCAA3D,GAA+FxF,MAAM,CAAC,KAAKqD,EAAN,CAArG,GAAiH,SAAjH,GAA6HoC,GAApI;MACD,CArBM,MAqBA;QACL,IAAIC,eAAe,GAAGvE,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe+D,KAAf,EAAsB;UACnD/D,GAAG,GAAGA,GAAG,CAACqE,MAAJ,CAAWhB,OAAX,CAAN;;UAEA,IAAIC,MAAM,CAACS,KAAD,CAAV,EAAmB;YACjB;YACA/D,GAAG,GAAG,mEAAmEA,GAAnE,GAAyE,gEAA/E;UACD;;UAED,OAAOA,GAAP;QACD,CATqB,CAAtB;;QAWA,IAAIT,IAAI,CAACO,MAAL,GAAc,CAAd,KAAoB,KAAKC,aAAL,OAAyB,kBAAzB,IAA+C,KAAKA,aAAL,OAAyB,uBAA5F,CAAJ,EAA0H;UACxH,IAAI,KAAKL,QAAL,IAAiB,KAAKK,aAAL,OAAyB,uBAA1C,IAAqEL,QAAQ,KAAK,MAAtF,EAA8F;YAC5F,OAAOoE,eAAe,CAACE,IAAhB,CAAqB,qDAAqD,wCAA1E,CAAP;UACD;;UAED,OAAOF,eAAe,CAACE,IAAhB,CAAqB,qDAAqD,iCAArD,GAAyF5F,MAAM,CAAC,KAAKqD,EAAN,CAA/F,GAA2G,SAAhI,CAAP;QACD,CAND,MAMO;UACL;UACA,OAAO,iCAAiCrD,MAAM,CAAC,KAAKsD,EAAN,CAAvC,GAAmD,+DAAnD,GAAqH,UAArH,GAAkIoC,eAAe,CAACE,IAAhB,CAAqB,uCAArB,CAAlI,GAAkM,gEAAzM;QACD;MACF;IACF;IACD;AACJ;AACA;AACA;AACA;;;IAGIM,MAAM,CAACjB,OAAD,EAAU;MACd,IAAIjE,WAAW,GAAGiE,OAAO,IAAIA,OAAO,CAACjE,WAAnB,GAAiCiE,OAAO,CAACjE,WAAzC,GAAuD,MAAzE;MACA,IAAIM,QAAQ,GAAG2D,OAAO,IAAIA,OAAO,CAAC3D,QAAnB,GAA8B2D,OAAO,CAAC3D,QAAtC,GAAiD,MAAhE;MACA,IAAIH,IAAI,GAAG,KAAKA,IAAhB;MACA,IAAI+D,MAAM,GAAG9D,6BAA6B,CAAC,IAAD,EAAOJ,WAAP,EAAoBM,QAApB,EAA8BH,IAA9B,EAAoC,IAApC,CAA1C;MACA,IAAIkC,EAAE,GAAG9C,cAAc,CAAC,KAAK+C,EAAN,CAAvB;MACAD,EAAE,GAAG,OAAOA,EAAP,KAAc,WAAd,GAA4B,KAAKA,EAAjC,GAAsCA,EAA3C,CANc,CAMiC;;MAE/C,IAAIlC,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QACrB;QACA,IAAIyD,KAAK,GAAGhF,gBAAgB,CAAC,IAAD,EAAOa,WAAP,CAA5B;QACA,IAAIoE,OAAO,GAAGjE,IAAI,CAAC,CAAD,CAAJ,CAAQgF,KAAR,CAAclB,OAAd,CAAd;;QAEA,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACbE,OAAO,GAAG,UAAUgB,MAAV,CAAiBhB,OAAjB,EAA0B,UAA1B,CAAV;QACD;;QAED,IAAID,KAAK,KAAK,OAAd,EAAuB;UACrB;UACA,OAAO9B,EAAE,GAAG+B,OAAZ;QACD,CAHD,MAGO,IAAID,KAAK,KAAK,MAAd,EAAsB;UAC3B;UACA,OAAOC,OAAO,GAAG/B,EAAjB;QACD,CAfoB,CAenB;;;QAGF,OAAO+B,OAAO,GAAG/B,EAAjB;MACD,CAnBD,MAmBO,IAAIlC,IAAI,CAACO,MAAL,KAAgB,CAApB,EAAuB;QAC5B;QACA,IAAI8D,GAAG,GAAGrE,IAAI,CAAC,CAAD,CAAd,CAF4B,CAET;;QAEnB,IAAIkF,MAAM,GAAGb,GAAG,CAACW,KAAJ,CAAUlB,OAAV,CAAb;;QAEA,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACbmB,MAAM,GAAG,UAAUD,MAAV,CAAiBC,MAAjB,EAAyB,UAAzB,CAAT;QACD;;QAED,IAAIZ,GAAG,GAAGtE,IAAI,CAAC,CAAD,CAAd,CAV4B,CAUT;;QAEnB,IAAImF,MAAM,GAAGb,GAAG,CAACU,KAAJ,CAAUlB,OAAV,CAAb;;QAEA,IAAIC,MAAM,CAAC,CAAD,CAAV,EAAe;UACboB,MAAM,GAAG,UAAUF,MAAV,CAAiBE,MAAjB,EAAyB,UAAzB,CAAT;QACD,CAhB2B,CAgB1B;;;QAGF,IAAI1D,aAAJ;;QAEA,IAAI5B,WAAW,KAAK,MAApB,EAA4B;UAC1B4B,aAAa,GAAG4C,GAAG,CAAC7D,aAAJ,EAAhB;QACD,CAFD,MAEO;UACL;UACAiB,aAAa,GAAG4C,GAAG,CAAC3D,UAAJ,GAAiBF,aAAjB,EAAhB;QACD;;QAED,QAAQ,KAAKA,aAAL,EAAR;UACE,KAAK,qBAAL;YACE;YACA,OAAO0B,EAAE,GAAG,GAAL,GAAWgD,MAAX,GAAoB,GAApB,GAA0B,GAA1B,GAAgCC,MAAhC,GAAyC,GAAhD;;UAEF,KAAK,kBAAL;YACED,MAAM,GAAG,MAAMA,MAAN,GAAe,GAAxB;YACAC,MAAM,GAAG,MAAMA,MAAN,GAAe,GAAxB;;YAEA,QAAQ1D,aAAR;cACE,KAAK,iBAAL,CADF,CAC0B;;cAExB,KAAK,qBAAL;gBACEyD,MAAM,GAAG,UAAUD,MAAV,CAAiBC,MAAjB,EAAyB,UAAzB,CAAT;YAJJ;;YAOA;;UAEF,KAAK,uBAAL;YACE,IAAI,KAAK/E,QAAL,IAAiBA,QAAQ,KAAK,MAAlC,EAA0C;cACxC,OAAO+E,MAAM,GAAG,GAAT,GAAeC,MAAtB;YACD;;QArBL;;QAyBA,OAAOD,MAAM,GAAGhD,EAAT,GAAciD,MAArB;MACD,CAtDM,MAsDA,IAAInF,IAAI,CAACO,MAAL,GAAc,CAAd,KAAoB,KAAKC,aAAL,OAAyB,kBAAzB,IAA+C,KAAKA,aAAL,OAAyB,uBAA5F,CAAJ,EAA0H;QAC/H,IAAI4E,YAAY,GAAGpF,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe+D,KAAf,EAAsB;UAChD/D,GAAG,GAAGA,GAAG,CAACuE,KAAJ,CAAUlB,OAAV,CAAN;;UAEA,IAAIC,MAAM,CAACS,KAAD,CAAV,EAAmB;YACjB/D,GAAG,GAAG,UAAUwE,MAAV,CAAiBxE,GAAjB,EAAsB,UAAtB,CAAN;UACD;;UAED,OAAOA,GAAP;QACD,CARkB,CAAnB;;QAUA,IAAI,KAAKD,aAAL,OAAyB,uBAAzB,IAAoD,KAAKL,QAAzD,IAAqEA,QAAQ,KAAK,MAAtF,EAA8F;UAC5F,OAAOiF,YAAY,CAACX,IAAb,CAAkB,GAAlB,CAAP;QACD;;QAED,OAAOW,YAAY,CAACX,IAAb,CAAkBvC,EAAlB,CAAP;MACD,CAhBM,MAgBA;QACL;QACA;QACA;QACA,OAAO,cAAc,KAAKC,EAAnB,GAAwB,UAAxB,GAAqCnC,IAAI,CAACpB,GAAL,CAAS,UAAU6B,GAAV,EAAe;UAClE,OAAOA,GAAG,CAACuE,KAAJ,CAAUlB,OAAV,CAAP;QACD,CAF2C,EAEzCW,IAFyC,CAEpC,GAFoC,CAArC,GAEQ,UAFf;MAGD;IACF;IACD;AACJ;AACA;AACA;;;IAGIjE,aAAa,GAAG;MACd,OAAO,KAAKG,IAAL,GAAY,GAAZ,GAAkB,KAAKwB,EAA9B;IACD;;EAvc6B;;EA2chC5D,eAAe,CAACyD,YAAD,EAAe,MAAf,EAAuB1C,IAAvB,CAAf;;EAEA,OAAO0C,YAAP;AACD,CAvsBqD,EAusBnD;EACDqD,OAAO,EAAE,IADR;EAED7G,MAAM,EAAE;AAFP,CAvsBmD,CAA/C"},"metadata":{},"sourceType":"module"}