{"ast":null,"code":"// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nimport { hasOwnProperty } from '../utils/object.js';\nimport { isConstantNode, isParenthesisNode, rule2Node } from '../utils/is.js';\nexport var properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    op: 'or',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    op: 'xor',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    op: 'and',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    op: '|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    op: '^|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    op: '&',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    op: '==',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    op: '!=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    op: '<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    op: '>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    op: '<=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    op: '>=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    op: '<<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    op: '>>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    op: '>>>',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    op: 'to',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    op: '+',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    op: '-',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    op: '*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    op: '/',\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    op: '.*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    op: './',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    op: 'mod',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // Repeat multiplication for implicit multiplication\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    op: '+',\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    op: '-',\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    op: '~',\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    op: 'not',\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    op: '^',\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    op: '.^',\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    op: '!',\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:ctranspose': {\n    op: \"'\",\n    associativity: 'left'\n  }\n}];\n/**\n * Returns the first non-parenthesis internal node, but only\n * when the 'parenthesis' option is unset or auto.\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {Node}\n */\n\nfunction unwrapParen(_node, parenthesis) {\n  if (!parenthesis || parenthesis !== 'auto') return _node;\n  var node = _node;\n\n  while (isParenthesisNode(node)) {\n    node = node.content;\n  }\n\n  return node;\n}\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @param {string} implicit\n * @param {Node} parent (for determining context for implicit multiplication)\n * @return {number | null}\n */\n\n\nexport function getPrecedence(_node, parenthesis, implicit, parent) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var precedence = null;\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      precedence = i;\n      break;\n    }\n  } // Bump up precedence of implicit multiplication, except when preceded\n  // by a \"Rule 2\" fraction ( [unaryOp]constant / constant )\n\n\n  if (identifier === 'OperatorNode:multiply' && node.implicit && implicit !== 'show') {\n    var leftArg = unwrapParen(node.args[0], parenthesis);\n\n    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {\n      precedence += 1;\n    }\n  }\n\n  return precedence;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\nexport function getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if (hasOwnProperty(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\nexport function isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}\n/**\n * Get the operator associated with a function name.\n * Returns a string with the operator symbol, or null if the\n * input is not the name of a function associated with an\n * operator.\n *\n * @param {string} Function name\n * @return {string | null} Associated operator symbol, if any\n */\n\nexport function getOperator(fn) {\n  var identifier = 'OperatorNode:' + fn;\n\n  for (var group of properties) {\n    if (identifier in group) {\n      return group[identifier].op;\n    }\n  }\n\n  return null;\n}","map":{"version":3,"names":["hasOwnProperty","isConstantNode","isParenthesisNode","rule2Node","properties","AssignmentNode","FunctionAssignmentNode","ConditionalNode","latexLeftParens","latexRightParens","latexParens","op","associativity","associativeWith","RelationalNode","RangeNode","unwrapParen","_node","parenthesis","node","content","getPrecedence","implicit","parent","getContent","identifier","getIdentifier","precedence","i","length","leftArg","args","getAssociativity","index","property","Error","isAssociativeWith","nodeA","nodeB","a","b","identifierA","identifierB","Array","getOperator","fn","group"],"sources":["/Users/gustavodurcak/node_modules/mathjs/lib/esm/expression/operators.js"],"sourcesContent":["// list of identifiers of nodes in order of their precedence\n// also contains information about left/right associativity\n// and which other operator the operator is associative with\n// Example:\n// addition is associative with addition and subtraction, because:\n// (a+b)+c=a+(b+c)\n// (a+b)-c=a+(b-c)\n//\n// postfix operators are left associative, prefix operators\n// are right associative\n//\n// It's also possible to set the following properties:\n// latexParens: if set to false, this node doesn't need to be enclosed\n//              in parentheses when using LaTeX\n// latexLeftParens: if set to false, this !OperatorNode's!\n//                  left argument doesn't need to be enclosed\n//                  in parentheses\n// latexRightParens: the same for the right argument\nimport { hasOwnProperty } from '../utils/object.js';\nimport { isConstantNode, isParenthesisNode, rule2Node } from '../utils/is.js';\nexport var properties = [{\n  // assignment\n  AssignmentNode: {},\n  FunctionAssignmentNode: {}\n}, {\n  // conditional expression\n  ConditionalNode: {\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // conditionals don't need parentheses in LaTeX because\n    // they are 2 dimensional\n\n  }\n}, {\n  // logical or\n  'OperatorNode:or': {\n    op: 'or',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical xor\n  'OperatorNode:xor': {\n    op: 'xor',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // logical and\n  'OperatorNode:and': {\n    op: 'and',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise or\n  'OperatorNode:bitOr': {\n    op: '|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise xor\n  'OperatorNode:bitXor': {\n    op: '^|',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitwise and\n  'OperatorNode:bitAnd': {\n    op: '&',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // relational operators\n  'OperatorNode:equal': {\n    op: '==',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:unequal': {\n    op: '!=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smaller': {\n    op: '<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:larger': {\n    op: '>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:smallerEq': {\n    op: '<=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:largerEq': {\n    op: '>=',\n    associativity: 'left',\n    associativeWith: []\n  },\n  RelationalNode: {\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // bitshift operators\n  'OperatorNode:leftShift': {\n    op: '<<',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightArithShift': {\n    op: '>>',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:rightLogShift': {\n    op: '>>>',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // unit conversion\n  'OperatorNode:to': {\n    op: 'to',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // range\n  RangeNode: {}\n}, {\n  // addition, subtraction\n  'OperatorNode:add': {\n    op: '+',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:add', 'OperatorNode:subtract']\n  },\n  'OperatorNode:subtract': {\n    op: '-',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // multiply, divide, modulus\n  'OperatorNode:multiply': {\n    op: '*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  },\n  'OperatorNode:divide': {\n    op: '/',\n    associativity: 'left',\n    associativeWith: [],\n    latexLeftParens: false,\n    latexRightParens: false,\n    latexParens: false // fractions don't require parentheses because\n    // they're 2 dimensional, so parens aren't needed\n    // in LaTeX\n\n  },\n  'OperatorNode:dotMultiply': {\n    op: '.*',\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'OperatorNode:dotMultiply', 'OperatorNode:doDivide']\n  },\n  'OperatorNode:dotDivide': {\n    op: './',\n    associativity: 'left',\n    associativeWith: []\n  },\n  'OperatorNode:mod': {\n    op: 'mod',\n    associativity: 'left',\n    associativeWith: []\n  }\n}, {\n  // Repeat multiplication for implicit multiplication\n  'OperatorNode:multiply': {\n    associativity: 'left',\n    associativeWith: ['OperatorNode:multiply', 'OperatorNode:divide', 'Operator:dotMultiply', 'Operator:dotDivide']\n  }\n}, {\n  // unary prefix operators\n  'OperatorNode:unaryPlus': {\n    op: '+',\n    associativity: 'right'\n  },\n  'OperatorNode:unaryMinus': {\n    op: '-',\n    associativity: 'right'\n  },\n  'OperatorNode:bitNot': {\n    op: '~',\n    associativity: 'right'\n  },\n  'OperatorNode:not': {\n    op: 'not',\n    associativity: 'right'\n  }\n}, {\n  // exponentiation\n  'OperatorNode:pow': {\n    op: '^',\n    associativity: 'right',\n    associativeWith: [],\n    latexRightParens: false // the exponent doesn't need parentheses in\n    // LaTeX because it's 2 dimensional\n    // (it's on top)\n\n  },\n  'OperatorNode:dotPow': {\n    op: '.^',\n    associativity: 'right',\n    associativeWith: []\n  }\n}, {\n  // factorial\n  'OperatorNode:factorial': {\n    op: '!',\n    associativity: 'left'\n  }\n}, {\n  // matrix transpose\n  'OperatorNode:ctranspose': {\n    op: \"'\",\n    associativity: 'left'\n  }\n}];\n/**\n * Returns the first non-parenthesis internal node, but only\n * when the 'parenthesis' option is unset or auto.\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {Node}\n */\n\nfunction unwrapParen(_node, parenthesis) {\n  if (!parenthesis || parenthesis !== 'auto') return _node;\n  var node = _node;\n\n  while (isParenthesisNode(node)) {\n    node = node.content;\n  }\n\n  return node;\n}\n/**\n * Get the precedence of a Node.\n * Higher number for higher precedence, starting with 0.\n * Returns null if the precedence is undefined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @param {string} implicit\n * @param {Node} parent (for determining context for implicit multiplication)\n * @return {number | null}\n */\n\n\nexport function getPrecedence(_node, parenthesis, implicit, parent) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var precedence = null;\n\n  for (var i = 0; i < properties.length; i++) {\n    if (identifier in properties[i]) {\n      precedence = i;\n      break;\n    }\n  } // Bump up precedence of implicit multiplication, except when preceded\n  // by a \"Rule 2\" fraction ( [unaryOp]constant / constant )\n\n\n  if (identifier === 'OperatorNode:multiply' && node.implicit && implicit !== 'show') {\n    var leftArg = unwrapParen(node.args[0], parenthesis);\n\n    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === 'OperatorNode:divide' && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {\n      precedence += 1;\n    }\n  }\n\n  return precedence;\n}\n/**\n * Get the associativity of an operator (left or right).\n * Returns a string containing 'left' or 'right' or null if\n * the associativity is not defined.\n *\n * @param {Node} _node\n * @param {string} parenthesis\n * @return {string|null}\n * @throws {Error}\n */\n\nexport function getAssociativity(_node, parenthesis) {\n  var node = _node;\n\n  if (parenthesis !== 'keep') {\n    // ParenthesisNodes are only ignored when not in 'keep' mode\n    node = _node.getContent();\n  }\n\n  var identifier = node.getIdentifier();\n  var index = getPrecedence(node, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifier];\n\n  if (hasOwnProperty(property, 'associativity')) {\n    if (property.associativity === 'left') {\n      return 'left';\n    }\n\n    if (property.associativity === 'right') {\n      return 'right';\n    } // associativity is invalid\n\n\n    throw Error('\\'' + identifier + '\\' has the invalid associativity \\'' + property.associativity + '\\'.');\n  } // associativity is undefined\n\n\n  return null;\n}\n/**\n * Check if an operator is associative with another operator.\n * Returns either true or false or null if not defined.\n *\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @param {string} parenthesis\n * @return {boolean | null}\n */\n\nexport function isAssociativeWith(nodeA, nodeB, parenthesis) {\n  // ParenthesisNodes are only ignored when not in 'keep' mode\n  var a = parenthesis !== 'keep' ? nodeA.getContent() : nodeA;\n  var b = parenthesis !== 'keep' ? nodeA.getContent() : nodeB;\n  var identifierA = a.getIdentifier();\n  var identifierB = b.getIdentifier();\n  var index = getPrecedence(a, parenthesis);\n\n  if (index === null) {\n    // node isn't in the list\n    return null;\n  }\n\n  var property = properties[index][identifierA];\n\n  if (hasOwnProperty(property, 'associativeWith') && property.associativeWith instanceof Array) {\n    for (var i = 0; i < property.associativeWith.length; i++) {\n      if (property.associativeWith[i] === identifierB) {\n        return true;\n      }\n    }\n\n    return false;\n  } // associativeWith is not defined\n\n\n  return null;\n}\n/**\n * Get the operator associated with a function name.\n * Returns a string with the operator symbol, or null if the\n * input is not the name of a function associated with an\n * operator.\n *\n * @param {string} Function name\n * @return {string | null} Associated operator symbol, if any\n */\n\nexport function getOperator(fn) {\n  var identifier = 'OperatorNode:' + fn;\n\n  for (var group of properties) {\n    if (identifier in group) {\n      return group[identifier].op;\n    }\n  }\n\n  return null;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}