{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  class ConditionalNode extends Node {\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    constructor(condition, trueExpr, falseExpr) {\n      super();\n\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n\n      this.condition = condition;\n      this.trueExpr = trueExpr;\n      this.falseExpr = falseExpr;\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isConditionalNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var evalCondition = this.condition._compile(math, argNames);\n\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n      return function evalConditionalNode(scope, args, context) {\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n      };\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.condition, 'condition', this);\n      callback(this.trueExpr, 'trueExpr', this);\n      callback(this.falseExpr, 'falseExpr', this);\n    }\n    /**\n     * Create a new ConditionalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ConditionalNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ConditionalNode}\n     */\n\n\n    clone() {\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toString(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '(' + condition + ')';\n      }\n\n      var trueExpr = this.trueExpr.toString(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '(' + trueExpr + ')';\n      }\n\n      var falseExpr = this.falseExpr.toString(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '(' + falseExpr + ')';\n      }\n\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        condition: this.condition,\n        trueExpr: this.trueExpr,\n        falseExpr: this.falseExpr\n      };\n    }\n    /**\n     * Instantiate an ConditionalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"ConditionalNode\",\n     *      \"condition\": ...,\n     *      \"trueExpr\": ...,\n     *      \"falseExpr\": ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {ConditionalNode}\n     */\n\n\n    static fromJSON(json) {\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toHTML(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var trueExpr = this.trueExpr.toHTML(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var falseExpr = this.falseExpr.toHTML(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n    }\n\n  }\n\n  _defineProperty(ConditionalNode, \"name\", name);\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","testCondition","condition","isZero","re","im","value","undefined","TypeError","ConditionalNode","constructor","trueExpr","falseExpr","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","implicit","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"sources":["/Users/gustavodurcak/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * Test whether a condition is met\n   * @param {*} condition\n   * @returns {boolean} true if condition is true or non-zero, else false\n   */\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  class ConditionalNode extends Node {\n    /**\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\n     *\n     * @param {Node} condition   Condition, must result in a boolean\n     * @param {Node} trueExpr    Expression evaluated when condition is true\n     * @param {Node} falseExpr   Expression evaluated when condition is true\n     *\n     * @constructor ConditionalNode\n     * @extends {Node}\n     */\n    constructor(condition, trueExpr, falseExpr) {\n      super();\n\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n\n      this.condition = condition;\n      this.trueExpr = trueExpr;\n      this.falseExpr = falseExpr;\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isConditionalNode() {\n      return true;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var evalCondition = this.condition._compile(math, argNames);\n\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n      return function evalConditionalNode(scope, args, context) {\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n      };\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.condition, 'condition', this);\n      callback(this.trueExpr, 'trueExpr', this);\n      callback(this.falseExpr, 'falseExpr', this);\n    }\n    /**\n     * Create a new ConditionalNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {ConditionalNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {ConditionalNode}\n     */\n\n\n    clone() {\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toString(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '(' + condition + ')';\n      }\n\n      var trueExpr = this.trueExpr.toString(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '(' + trueExpr + ')';\n      }\n\n      var falseExpr = this.falseExpr.toString(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '(' + falseExpr + ')';\n      }\n\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        condition: this.condition,\n        trueExpr: this.trueExpr,\n        falseExpr: this.falseExpr\n      };\n    }\n    /**\n     * Instantiate an ConditionalNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     ```\n     *     {\"mathjs\": \"ConditionalNode\",\n     *      \"condition\": ...,\n     *      \"trueExpr\": ...,\n     *      \"falseExpr\": ...}\n     *     ```\n     *     where mathjs is optional\n     * @returns {ConditionalNode}\n     */\n\n\n    static fromJSON(json) {\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toHTML(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var trueExpr = this.trueExpr.toHTML(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var falseExpr = this.falseExpr.toHTML(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n    }\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n    }\n\n  }\n\n  _defineProperty(ConditionalNode, \"name\", name);\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}