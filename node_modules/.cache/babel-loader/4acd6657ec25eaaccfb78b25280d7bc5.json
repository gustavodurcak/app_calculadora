{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super(); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n\n      this.end = end; // included upper-bound\n\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isRangeNode() {\n      return true;\n    }\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n\n\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var range = math.range;\n\n      var evalStart = this.start._compile(math, argNames);\n\n      var evalEnd = this.end._compile(math, argNames);\n\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n\n\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toString(options);\n\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toString(options);\n\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toString(options);\n\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n\n      str += ':' + end;\n      return str;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n\n\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toHTML(options);\n\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toHTML(options);\n\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n\n      var end = this.end.toHTML(options);\n\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n\n      if (this.step) {\n        var step = this.step.toTex(options);\n\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toTex(options);\n\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n\n      str += ':' + end;\n      return str;\n    }\n\n  }\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","constructor","TypeError","arguments","length","Error","type","isRangeNode","needsEnd","endSymbols","filter","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"sources":["/Users/gustavodurcak/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * Calculate the necessary parentheses\n   * @param {Node} node\n   * @param {string} parenthesis\n   * @param {string} implicit\n   * @return {Object} parentheses\n   * @private\n   */\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  class RangeNode extends Node {\n    /**\n     * @constructor RangeNode\n     * @extends {Node}\n     * create a range\n     * @param {Node} start  included lower-bound\n     * @param {Node} end    included upper-bound\n     * @param {Node} [step] optional step\n     */\n    constructor(start, end, step) {\n      super(); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n\n      this.end = end; // included upper-bound\n\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isRangeNode() {\n      return true;\n    }\n    /**\n     * Check whether the RangeNode needs the `end` symbol to be defined.\n     * This end is the size of the Matrix in current dimension.\n     * @return {boolean}\n     */\n\n\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n\n\n    _compile(math, argNames) {\n      var range = math.range;\n\n      var evalStart = this.start._compile(math, argNames);\n\n      var evalEnd = this.end._compile(math, argNames);\n\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n\n\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n    /**\n     * Create a new RangeNode whose children are the results of calling\n     * the provided callback function for each child of the original node.\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\n     * @returns {RangeNode} Returns a transformed copy of the node\n     */\n\n\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {RangeNode}\n     */\n\n\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toString(options);\n\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toString(options);\n\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toString(options);\n\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n\n      str += ':' + end;\n      return str;\n    }\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n    /**\n     * Instantiate an RangeNode from its JSON representation\n     * @param {Object} json\n     *     An object structured like\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\n     *     where mathjs is optional\n     * @returns {RangeNode}\n     */\n\n\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toHTML(options);\n\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toHTML(options);\n\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n\n      var end = this.end.toHTML(options);\n\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n    /**\n     * Get LaTeX representation\n     * @params {Object} options\n     * @return {string} str\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n\n      if (this.step) {\n        var step = this.step.toTex(options);\n\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toTex(options);\n\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n\n      str += ':' + end;\n      return str;\n    }\n\n  }\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}